// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "audio_processing_unittest.pb.h"
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
// @@protoc_insertion_point(includes)

namespace audio_processing_unittest {

void protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto() {
  delete Test::default_instance_;
  delete Test_Frame::default_instance_;
  delete Test_Statistic::default_instance_;
  delete Test_EchoMetrics::default_instance_;
  delete OutputData::default_instance_;
}

void protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  Test::default_instance_ = new Test();
  Test_Frame::default_instance_ = new Test_Frame();
  Test_Statistic::default_instance_ = new Test_Statistic();
  Test_EchoMetrics::default_instance_ = new Test_EchoMetrics();
  OutputData::default_instance_ = new OutputData();
  Test::default_instance_->InitAsDefaultInstance();
  Test_Frame::default_instance_->InitAsDefaultInstance();
  Test_Statistic::default_instance_->InitAsDefaultInstance();
  Test_EchoMetrics::default_instance_->InitAsDefaultInstance();
  OutputData::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_audio_5fprocessing_5funittest_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_audio_5fprocessing_5funittest_2eproto {
  StaticDescriptorInitializer_audio_5fprocessing_5funittest_2eproto() {
    protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();
  }
} static_descriptor_initializer_audio_5fprocessing_5funittest_2eproto_;


// ===================================================================

#ifndef _MSC_VER
#endif  // !_MSC_VER

Test_Frame::Test_Frame()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test_Frame::InitAsDefaultInstance() {
}

Test_Frame::Test_Frame(const Test_Frame& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test_Frame::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_Frame::~Test_Frame() {
  SharedDtor();
}

void Test_Frame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Test_Frame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_Frame& Test_Frame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test_Frame* Test_Frame::default_instance_ = NULL;

Test_Frame* Test_Frame::New() const {
  return new Test_Frame;
}

void Test_Frame::Clear() {
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test_Frame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      return true;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
  return true;
#undef DO_
}

void Test_Frame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
}

int Test_Frame::ByteSize() const {
  int total_size = 0;
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_Frame::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Frame*>(&from));
}

void Test_Frame::MergeFrom(const Test_Frame& from) {
  GOOGLE_CHECK_NE(&from, this);
}

void Test_Frame::CopyFrom(const Test_Frame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Frame::IsInitialized() const {
  
  return true;
}

void Test_Frame::Swap(Test_Frame* other) {
  if (other != this) {
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test_Frame::GetTypeName() const {
  return "audio_processing_unittest.Test.Frame";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Test_Statistic::kInstantFieldNumber;
const int Test_Statistic::kAverageFieldNumber;
const int Test_Statistic::kMaximumFieldNumber;
const int Test_Statistic::kMinimumFieldNumber;
#endif  // !_MSC_VER

Test_Statistic::Test_Statistic()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test_Statistic::InitAsDefaultInstance() {
}

Test_Statistic::Test_Statistic(const Test_Statistic& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test_Statistic::SharedCtor() {
  _cached_size_ = 0;
  instant_ = 0;
  average_ = 0;
  maximum_ = 0;
  minimum_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_Statistic::~Test_Statistic() {
  SharedDtor();
}

void Test_Statistic::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Test_Statistic::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_Statistic& Test_Statistic::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test_Statistic* Test_Statistic::default_instance_ = NULL;

Test_Statistic* Test_Statistic::New() const {
  return new Test_Statistic;
}

void Test_Statistic::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    instant_ = 0;
    average_ = 0;
    maximum_ = 0;
    minimum_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test_Statistic::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 instant = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &instant_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_average;
        break;
      }
      
      // optional int32 average = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &average_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_maximum;
        break;
      }
      
      // optional int32 maximum = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_maximum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &maximum_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_minimum;
        break;
      }
      
      // optional int32 minimum = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_minimum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &minimum_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test_Statistic::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 instant = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->instant(), output);
  }
  
  // optional int32 average = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->average(), output);
  }
  
  // optional int32 maximum = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->maximum(), output);
  }
  
  // optional int32 minimum = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->minimum(), output);
  }
  
}

int Test_Statistic::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 instant = 1;
    if (has_instant()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->instant());
    }
    
    // optional int32 average = 2;
    if (has_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->average());
    }
    
    // optional int32 maximum = 3;
    if (has_maximum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->maximum());
    }
    
    // optional int32 minimum = 4;
    if (has_minimum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->minimum());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_Statistic::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_Statistic*>(&from));
}

void Test_Statistic::MergeFrom(const Test_Statistic& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_instant(from.instant());
    }
    if (from._has_bit(1)) {
      set_average(from.average());
    }
    if (from._has_bit(2)) {
      set_maximum(from.maximum());
    }
    if (from._has_bit(3)) {
      set_minimum(from.minimum());
    }
  }
}

void Test_Statistic::CopyFrom(const Test_Statistic& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_Statistic::IsInitialized() const {
  
  return true;
}

void Test_Statistic::Swap(Test_Statistic* other) {
  if (other != this) {
    std::swap(instant_, other->instant_);
    std::swap(average_, other->average_);
    std::swap(maximum_, other->maximum_);
    std::swap(minimum_, other->minimum_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test_Statistic::GetTypeName() const {
  return "audio_processing_unittest.Test.Statistic";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Test_EchoMetrics::kResidualEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossFieldNumber;
const int Test_EchoMetrics::kEchoReturnLossEnhancementFieldNumber;
const int Test_EchoMetrics::kANlpFieldNumber;
#endif  // !_MSC_VER

Test_EchoMetrics::Test_EchoMetrics()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test_EchoMetrics::InitAsDefaultInstance() {
  residual_echo_return_loss_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  echo_return_loss_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  echo_return_loss_enhancement_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
  a_nlp_ = const_cast< ::audio_processing_unittest::Test_Statistic*>(&::audio_processing_unittest::Test_Statistic::default_instance());
}

Test_EchoMetrics::Test_EchoMetrics(const Test_EchoMetrics& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test_EchoMetrics::SharedCtor() {
  _cached_size_ = 0;
  residual_echo_return_loss_ = NULL;
  echo_return_loss_ = NULL;
  echo_return_loss_enhancement_ = NULL;
  a_nlp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test_EchoMetrics::~Test_EchoMetrics() {
  SharedDtor();
}

void Test_EchoMetrics::SharedDtor() {
  if (this != default_instance_) {
    delete residual_echo_return_loss_;
    delete echo_return_loss_;
    delete echo_return_loss_enhancement_;
    delete a_nlp_;
  }
}

void Test_EchoMetrics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test_EchoMetrics& Test_EchoMetrics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test_EchoMetrics* Test_EchoMetrics::default_instance_ = NULL;

Test_EchoMetrics* Test_EchoMetrics::New() const {
  return new Test_EchoMetrics;
}

void Test_EchoMetrics::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (_has_bit(0)) {
      if (residual_echo_return_loss_ != NULL) residual_echo_return_loss_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (_has_bit(1)) {
      if (echo_return_loss_ != NULL) echo_return_loss_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (_has_bit(2)) {
      if (echo_return_loss_enhancement_ != NULL) echo_return_loss_enhancement_->::audio_processing_unittest::Test_Statistic::Clear();
    }
    if (_has_bit(3)) {
      if (a_nlp_ != NULL) a_nlp_->::audio_processing_unittest::Test_Statistic::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test_EchoMetrics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .audio_processing_unittest.Test.Statistic residual_echo_return_loss = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_residual_echo_return_loss()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_echo_return_loss;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic echo_return_loss = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echo_return_loss:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo_return_loss()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_echo_return_loss_enhancement;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic echo_return_loss_enhancement = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echo_return_loss_enhancement:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo_return_loss_enhancement()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_a_nlp;
        break;
      }
      
      // optional .audio_processing_unittest.Test.Statistic a_nlp = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_a_nlp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_a_nlp()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test_EchoMetrics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .audio_processing_unittest.Test.Statistic residual_echo_return_loss = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->residual_echo_return_loss(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic echo_return_loss = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->echo_return_loss(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic echo_return_loss_enhancement = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->echo_return_loss_enhancement(), output);
  }
  
  // optional .audio_processing_unittest.Test.Statistic a_nlp = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->a_nlp(), output);
  }
  
}

int Test_EchoMetrics::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .audio_processing_unittest.Test.Statistic residual_echo_return_loss = 1;
    if (has_residual_echo_return_loss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->residual_echo_return_loss());
    }
    
    // optional .audio_processing_unittest.Test.Statistic echo_return_loss = 2;
    if (has_echo_return_loss()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echo_return_loss());
    }
    
    // optional .audio_processing_unittest.Test.Statistic echo_return_loss_enhancement = 3;
    if (has_echo_return_loss_enhancement()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echo_return_loss_enhancement());
    }
    
    // optional .audio_processing_unittest.Test.Statistic a_nlp = 4;
    if (has_a_nlp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->a_nlp());
    }
    
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test_EchoMetrics::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test_EchoMetrics*>(&from));
}

void Test_EchoMetrics::MergeFrom(const Test_EchoMetrics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      mutable_residual_echo_return_loss()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.residual_echo_return_loss());
    }
    if (from._has_bit(1)) {
      mutable_echo_return_loss()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.echo_return_loss());
    }
    if (from._has_bit(2)) {
      mutable_echo_return_loss_enhancement()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.echo_return_loss_enhancement());
    }
    if (from._has_bit(3)) {
      mutable_a_nlp()->::audio_processing_unittest::Test_Statistic::MergeFrom(from.a_nlp());
    }
  }
}

void Test_EchoMetrics::CopyFrom(const Test_EchoMetrics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test_EchoMetrics::IsInitialized() const {
  
  return true;
}

void Test_EchoMetrics::Swap(Test_EchoMetrics* other) {
  if (other != this) {
    std::swap(residual_echo_return_loss_, other->residual_echo_return_loss_);
    std::swap(echo_return_loss_, other->echo_return_loss_);
    std::swap(echo_return_loss_enhancement_, other->echo_return_loss_enhancement_);
    std::swap(a_nlp_, other->a_nlp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test_EchoMetrics::GetTypeName() const {
  return "audio_processing_unittest.Test.EchoMetrics";
}


// -------------------------------------------------------------------

#ifndef _MSC_VER
const int Test::kNumReverseChannelsFieldNumber;
const int Test::kNumInputChannelsFieldNumber;
const int Test::kNumOutputChannelsFieldNumber;
const int Test::kSampleRateFieldNumber;
const int Test::kFrameFieldNumber;
const int Test::kAnalogLevelAverageFieldNumber;
const int Test::kMaxOutputAverageFieldNumber;
const int Test::kHasEchoCountFieldNumber;
const int Test::kHasVoiceCountFieldNumber;
const int Test::kIsSaturatedCountFieldNumber;
const int Test::kEchoMetricsFieldNumber;
#endif  // !_MSC_VER

Test::Test()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void Test::InitAsDefaultInstance() {
  echo_metrics_ = const_cast< ::audio_processing_unittest::Test_EchoMetrics*>(&::audio_processing_unittest::Test_EchoMetrics::default_instance());
}

Test::Test(const Test& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void Test::SharedCtor() {
  _cached_size_ = 0;
  num_reverse_channels_ = 0;
  num_input_channels_ = 0;
  num_output_channels_ = 0;
  sample_rate_ = 0;
  analog_level_average_ = 0;
  max_output_average_ = 0;
  has_echo_count_ = 0;
  has_voice_count_ = 0;
  is_saturated_count_ = 0;
  echo_metrics_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Test::~Test() {
  SharedDtor();
}

void Test::SharedDtor() {
  if (this != default_instance_) {
    delete echo_metrics_;
  }
}

void Test::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Test& Test::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

Test* Test::default_instance_ = NULL;

Test* Test::New() const {
  return new Test;
}

void Test::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    num_reverse_channels_ = 0;
    num_input_channels_ = 0;
    num_output_channels_ = 0;
    sample_rate_ = 0;
    analog_level_average_ = 0;
    max_output_average_ = 0;
    has_echo_count_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    has_voice_count_ = 0;
    is_saturated_count_ = 0;
    if (_has_bit(10)) {
      if (echo_metrics_ != NULL) echo_metrics_->::audio_processing_unittest::Test_EchoMetrics::Clear();
    }
  }
  frame_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool Test::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 num_reverse_channels = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_reverse_channels_)));
          _set_bit(0);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_num_input_channels;
        break;
      }
      
      // optional int32 num_input_channels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_input_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_input_channels_)));
          _set_bit(1);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_num_output_channels;
        break;
      }
      
      // optional int32 num_output_channels = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_num_output_channels:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &num_output_channels_)));
          _set_bit(2);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_sample_rate;
        break;
      }
      
      // optional int32 sample_rate = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_sample_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &sample_rate_)));
          _set_bit(3);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_frame;
        break;
      }
      
      // repeated .audio_processing_unittest.Test.Frame frame = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_frame:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_frame()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_frame;
        if (input->ExpectTag(48)) goto parse_analog_level_average;
        break;
      }
      
      // optional int32 analog_level_average = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_analog_level_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &analog_level_average_)));
          _set_bit(5);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_max_output_average;
        break;
      }
      
      // optional int32 max_output_average = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_max_output_average:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &max_output_average_)));
          _set_bit(6);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_has_echo_count;
        break;
      }
      
      // optional int32 has_echo_count = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_echo_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_echo_count_)));
          _set_bit(7);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_has_voice_count;
        break;
      }
      
      // optional int32 has_voice_count = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_has_voice_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &has_voice_count_)));
          _set_bit(8);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_is_saturated_count;
        break;
      }
      
      // optional int32 is_saturated_count = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_is_saturated_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &is_saturated_count_)));
          _set_bit(9);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(90)) goto parse_echo_metrics;
        break;
      }
      
      // optional .audio_processing_unittest.Test.EchoMetrics echo_metrics = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_echo_metrics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_echo_metrics()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Test::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional int32 num_reverse_channels = 1;
  if (_has_bit(0)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->num_reverse_channels(), output);
  }
  
  // optional int32 num_input_channels = 2;
  if (_has_bit(1)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->num_input_channels(), output);
  }
  
  // optional int32 num_output_channels = 3;
  if (_has_bit(2)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->num_output_channels(), output);
  }
  
  // optional int32 sample_rate = 4;
  if (_has_bit(3)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->sample_rate(), output);
  }
  
  // repeated .audio_processing_unittest.Test.Frame frame = 5;
  for (int i = 0; i < this->frame_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, this->frame(i), output);
  }
  
  // optional int32 analog_level_average = 6;
  if (_has_bit(5)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->analog_level_average(), output);
  }
  
  // optional int32 max_output_average = 7;
  if (_has_bit(6)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(7, this->max_output_average(), output);
  }
  
  // optional int32 has_echo_count = 8;
  if (_has_bit(7)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->has_echo_count(), output);
  }
  
  // optional int32 has_voice_count = 9;
  if (_has_bit(8)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(9, this->has_voice_count(), output);
  }
  
  // optional int32 is_saturated_count = 10;
  if (_has_bit(9)) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(10, this->is_saturated_count(), output);
  }
  
  // optional .audio_processing_unittest.Test.EchoMetrics echo_metrics = 11;
  if (_has_bit(10)) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      11, this->echo_metrics(), output);
  }
  
}

int Test::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 num_reverse_channels = 1;
    if (has_num_reverse_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_reverse_channels());
    }
    
    // optional int32 num_input_channels = 2;
    if (has_num_input_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_input_channels());
    }
    
    // optional int32 num_output_channels = 3;
    if (has_num_output_channels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->num_output_channels());
    }
    
    // optional int32 sample_rate = 4;
    if (has_sample_rate()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->sample_rate());
    }
    
    // optional int32 analog_level_average = 6;
    if (has_analog_level_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->analog_level_average());
    }
    
    // optional int32 max_output_average = 7;
    if (has_max_output_average()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->max_output_average());
    }
    
    // optional int32 has_echo_count = 8;
    if (has_has_echo_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->has_echo_count());
    }
    
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int32 has_voice_count = 9;
    if (has_has_voice_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->has_voice_count());
    }
    
    // optional int32 is_saturated_count = 10;
    if (has_is_saturated_count()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->is_saturated_count());
    }
    
    // optional .audio_processing_unittest.Test.EchoMetrics echo_metrics = 11;
    if (has_echo_metrics()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->echo_metrics());
    }
    
  }
  // repeated .audio_processing_unittest.Test.Frame frame = 5;
  total_size += 1 * this->frame_size();
  for (int i = 0; i < this->frame_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frame(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Test::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Test*>(&from));
}

void Test::MergeFrom(const Test& from) {
  GOOGLE_CHECK_NE(&from, this);
  frame_.MergeFrom(from.frame_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from._has_bit(0)) {
      set_num_reverse_channels(from.num_reverse_channels());
    }
    if (from._has_bit(1)) {
      set_num_input_channels(from.num_input_channels());
    }
    if (from._has_bit(2)) {
      set_num_output_channels(from.num_output_channels());
    }
    if (from._has_bit(3)) {
      set_sample_rate(from.sample_rate());
    }
    if (from._has_bit(5)) {
      set_analog_level_average(from.analog_level_average());
    }
    if (from._has_bit(6)) {
      set_max_output_average(from.max_output_average());
    }
    if (from._has_bit(7)) {
      set_has_echo_count(from.has_echo_count());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from._has_bit(8)) {
      set_has_voice_count(from.has_voice_count());
    }
    if (from._has_bit(9)) {
      set_is_saturated_count(from.is_saturated_count());
    }
    if (from._has_bit(10)) {
      mutable_echo_metrics()->::audio_processing_unittest::Test_EchoMetrics::MergeFrom(from.echo_metrics());
    }
  }
}

void Test::CopyFrom(const Test& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Test::IsInitialized() const {
  
  return true;
}

void Test::Swap(Test* other) {
  if (other != this) {
    std::swap(num_reverse_channels_, other->num_reverse_channels_);
    std::swap(num_input_channels_, other->num_input_channels_);
    std::swap(num_output_channels_, other->num_output_channels_);
    std::swap(sample_rate_, other->sample_rate_);
    frame_.Swap(&other->frame_);
    std::swap(analog_level_average_, other->analog_level_average_);
    std::swap(max_output_average_, other->max_output_average_);
    std::swap(has_echo_count_, other->has_echo_count_);
    std::swap(has_voice_count_, other->has_voice_count_);
    std::swap(is_saturated_count_, other->is_saturated_count_);
    std::swap(echo_metrics_, other->echo_metrics_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string Test::GetTypeName() const {
  return "audio_processing_unittest.Test";
}


// ===================================================================

#ifndef _MSC_VER
const int OutputData::kTestFieldNumber;
#endif  // !_MSC_VER

OutputData::OutputData()
  : ::google::protobuf::MessageLite() {
  SharedCtor();
}

void OutputData::InitAsDefaultInstance() {
}

OutputData::OutputData(const OutputData& from)
  : ::google::protobuf::MessageLite() {
  SharedCtor();
  MergeFrom(from);
}

void OutputData::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OutputData::~OutputData() {
  SharedDtor();
}

void OutputData::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OutputData::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const OutputData& OutputData::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_audio_5fprocessing_5funittest_2eproto();  return *default_instance_;
}

OutputData* OutputData::default_instance_ = NULL;

OutputData* OutputData::New() const {
  return new OutputData;
}

void OutputData::Clear() {
  test_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

bool OutputData::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .audio_processing_unittest.Test test = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_test:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_test()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_test;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OutputData::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .audio_processing_unittest.Test test = 1;
  for (int i = 0; i < this->test_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->test(i), output);
  }
  
}

int OutputData::ByteSize() const {
  int total_size = 0;
  
  // repeated .audio_processing_unittest.Test test = 1;
  total_size += 1 * this->test_size();
  for (int i = 0; i < this->test_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->test(i));
  }
  
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OutputData::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const OutputData*>(&from));
}

void OutputData::MergeFrom(const OutputData& from) {
  GOOGLE_CHECK_NE(&from, this);
  test_.MergeFrom(from.test_);
}

void OutputData::CopyFrom(const OutputData& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OutputData::IsInitialized() const {
  
  return true;
}

void OutputData::Swap(OutputData* other) {
  if (other != this) {
    test_.Swap(&other->test_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::std::string OutputData::GetTypeName() const {
  return "audio_processing_unittest.OutputData";
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace audio_processing_unittest

// @@protoc_insertion_point(global_scope)
